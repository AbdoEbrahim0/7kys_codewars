#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <cassert>
#include <string>
#include <algorithm>
#include <cstring>
#include <stdio.h>
#include <regex>
#include <numeric>
#include <stdlib.h>
#include <map>
#include <numeric>
#include<sstream>
#include <set>
#include <cstdint>
#include <array>
#include <utility>
#include <string>
#include <cmath>
#include <vector>
#include <list>
#include<unordered_set>

using namespace std;
//methode 1 complexty : O(1)
using namespace std;

vector<uint64_t > get_prime_mult(uint64_t num)
{
    vector<uint64_t >vec;
    if (num == 1) return{ 1 };
    if (num == 0) return{ 0 }; //if pair is empty 
    float dividor = 2;
    while (true)
    {
        if (num / dividor == floor(num / dividor))
        {
            vec.push_back(dividor);
            num = num / dividor;
            dividor = 1;
        }
        dividor++;
        if (num == 0 || num == 1) break;
    }
    return vec;
}
uint64_t sum_differences_between_products_and_LCMs(const vector<pair<uint64_t, uint64_t> >& pairs)
{
    vector<uint64_t >vec_1, vec_2, primeFactors;
    vector<uint64_t > lcm_vector, product_vector;
    
    for (pair<uint64_t, uint64_t>  current_val : pairs)
    {
        vec_1= get_prime_mult(current_val.first);
        vec_2 = get_prime_mult(current_val.second);
        product_vector.push_back(current_val.first * current_val.second);
        for (int i = 0; i < vec_1.size(); )
        {
            for (int j = 0; j < vec_2.size() && i < vec_1.size();)
            {
                auto it = find(vec_2.begin(), vec_2.end(), vec_1.at(i));
                if (vec_1.at(i) == vec_2.at(j))
                {
                    primeFactors.push_back(vec_1.at(i));
                    i++;
                    j++;
                }
                else if(vec_1.at(i) > vec_2.at(j) && it != vec_2.end())
                    j++;
                
                else 
                    i++;
                
            }
        }

        vector<uint64_t >::iterator value;
        for (value=primeFactors.begin(); value< primeFactors.end(); value++)
        {
            auto it_1 = find(vec_1.begin(), vec_1.end(), *value);
            auto it_2 = find(vec_2.begin(), vec_2.end(), *value);
            if (it_1 != vec_1.end()) //then it erased so we will not increment 
            {
                vec_1.erase(it_1);
            }
            if (it_2 != vec_2.end()) //then it erased so we will not increment 
            {
                vec_2.erase(it_2);
            }
        }
        uint64_t lcm = 1;
        for (uint64_t common : primeFactors)
        {
            lcm = lcm * common;
        }
        primeFactors.clear();
        for (uint64_t varient_1 : vec_1)
        {
            lcm = lcm * varient_1;
        }
        for (uint64_t varient_2 : vec_2)
        {
            lcm = lcm * varient_2;
        }
        
        lcm_vector.push_back(lcm);
        
    }
    for (uint64_t lcm_val : lcm_vector) cout << lcm_val << " ";
    cout << "\n------------\n";
    for (uint64_t prod_val : product_vector) cout << prod_val << " ";
    cout << "\n------------\n";
    vector <uint64_t>sum_differences_between_products_and_LCMs_vector;
    for (int z = 0; z < product_vector.size(); z++)
    {
        sum_differences_between_products_and_LCMs_vector.push_back(product_vector.at(z) - lcm_vector.at(z));
    }


    return accumulate(sum_differences_between_products_and_LCMs_vector.begin(), sum_differences_between_products_and_LCMs_vector.end(),0); // Do your magic!


}


int main() {
    
    cout << sum_differences_between_products_and_LCMs({ {15,18}, {4,5}, {12,60} }) <<" <<\n"; //840
    cout << sum_differences_between_products_and_LCMs({ {1, 1}, { 0,0 }, { 13,91 } }) << "<<\n";//1092
    cout << sum_differences_between_products_and_LCMs({ {15,7}, {4,5}, {19,60} }) << "<<\n";//0
    cout << sum_differences_between_products_and_LCMs({ {20,50}, {10,10}, {50,20} }) << "<<\n";//1890
    cout << sum_differences_between_products_and_LCMs({ {} }); //0
    
    //cout << sum_differences_between_products_and_LCMs({ { 60,42 }});
    

    return 0;
}
